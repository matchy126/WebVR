<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>MR Tree Decorating — Tap to Place + Grab & Throw (Stable)</title>

  <!-- A-Frame -->
  <script src="https://cdn.jsdelivr.net/npm/aframe@1.4.2/dist/aframe.min.js"></script>
  <!-- AR hit test for A-Frame -->
  <script src="https://cdn.jsdelivr.net/npm/aframe-ar-hit-test-component@1.0.3/dist/aframe-ar-hit-test-component.min.js"></script>
  <!-- three + STLLoader -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.154.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.154.0/examples/js/loaders/STLLoader.js"></script>

  <!-- physics + interactions -->
  <script src="https://cdn.jsdelivr.net/gh/n5ro/aframe-physics-system@v4.0.1/dist/aframe-physics-system.min.js"></script>
  <script src="https://cdn.jsdelivr.net/gh/wmurphyrd/aframe-super-hands-component@7.0.3/dist/aframe-super-hands.min.js"></script>

  <style>
    body { margin:0; font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans JP"; }
    #ui {
      position: absolute; left: 12px; top: 12px; z-index: 10;
      background: rgba(0,0,0,0.55); color: white; padding: 8px 10px; border-radius: 6px;
      max-width: 380px; font-size: 13px;
    }
    #placeHint { display:inline-block; margin-top:6px; color:#ffd; }
  </style>
</head>
<body>
  <div id="ui">
    Tap the floor to place the tree.  
    Use controller primary button (A/X) to spawn an ornament; grab with trigger and throw.  
    On hit the ornament will snap and twinkle — then become fixed (cannot be removed).  
    <div id="placeHint"></div>
  </div>

  <a-scene
    vr-mode-ui="enabled: true"
    webxr="optionalFeatures: hit-test, anchors, local-floor, bounded-floor; requiredFeatures: hit-test; sessionMode: immersive-ar"
    ar-hit-test
    physics="gravity: -9.8; debug: false"
    renderer="antialias: true; colorManagement: true"
    background="color: #00000000" > <!-- transparent for passthrough -->
    
    <!-- reticle -->
    <a-entity id="reticle" visible="false"
              geometry="primitive: ring; radiusInner: 0.03; radiusOuter: 0.05"
              material="color: #ffff66; side: double; shader: flat"
              rotation="-90 0 0"></a-entity>

    <!-- scene root -->
    <a-entity id="root"></a-entity>

    <!-- camera rig -->
    <a-entity id="cameraRig" position="0 1.6 0">
      <a-entity camera look-controls></a-entity>

      <!-- controllers -->
      <a-entity id="rightHand"
                hand-controls="hand: right"
                oculus-touch-controls="hand: right"
                super-hands
                raycaster="objects: .grabbable"></a-entity>

      <a-entity id="leftHand"
                hand-controls="hand: left"
                oculus-touch-controls="hand: left"
                super-hands
                raycaster="objects: .grabbable"></a-entity>
    </a-entity>

    <!-- invisible physics ground for fallback -->
    <a-plane id="physicsGround" rotation="-90 0 0" width="50" height="50" visible="false" static-body></a-plane>

    <!-- directional light (casts shadows) -->
    <a-entity id="sun" light="type: directional; intensity: 1" position="2 5 1" rotation="-45 30 0"></a-entity>
    <!-- ambient -->
    <a-entity light="type: ambient; color: #888"></a-entity>
  </a-scene>

<script>
/* -------------------------
 Config (user paths chosen)
------------------------- */
const TREE_STL = './tree.stl';
const ORNAMENT_STL = './ornament.stl';
const ORNAMENT_SCALE = 0.02;
const ORNAMENT_OFFSET = 0.02;
const SPAWN_DISTANCE = 0.35;
const MAX_ORNAMENTS = 80;

/* -------------------------
 Helpers: load STL (returns THREE.BufferGeometry)
------------------------- */
function loadSTL(url) {
  return new Promise((resolve, reject) => {
    const loader = new THREE.STLLoader();
    loader.load(url, g => resolve(g), undefined, e => reject(e));
  });
}

/* -------------------------
 Face computation utilities
 - converts BufferGeometry (non-indexed) into array of face {centroid, normal}
 - returns centroids/normals in geometry local space
------------------------- */
function computeFacesFromGeometry(geometry) {
  let geo = geometry.index ? geometry.toNonIndexed() : geometry.clone();
  const pos = geo.attributes.position.array;
  const faces = [];
  for (let i = 0; i < pos.length; i += 9) {
    const ax = pos[i], ay = pos[i+1], az = pos[i+2];
    const bx = pos[i+3], by = pos[i+4], bz = pos[i+5];
    const cx = pos[i+6], cy = pos[i+7], cz = pos[i+8];
    const centroid = new THREE.Vector3((ax+bx+cx)/3, (ay+by+cy)/3, (az+bz+cz)/3);
    const ab = new THREE.Vector3(bx-ax, by-ay, bz-az);
    const ac = new THREE.Vector3(cx-ax, cy-ay, cz-az);
    const normal = new THREE.Vector3().crossVectors(ab, ac).normalize();
    faces.push({ centroid, normal });
  }
  return faces;
}

/* -------------------------
 Main decorator component
------------------------- */
AFRAME.registerComponent('mr-decorator-stable', {
  init: function () {
    const sceneEl = this.el.sceneEl;
    this.treePlaced = false;
    this.treeEntity = null;
    this.treeMesh = null;          // THREE.Mesh (visual)
    this.treeGeo = null;           // geometry used for face sampling (local)
    this.treeFaces = null;         // face list in geometry local space
    this.ornamentTemplate = null;
    this.ornaments = [];

    // enable renderer shadowMap once renderer is available
    sceneEl.addEventListener('renderstart', () => {
      if (sceneEl.renderer) {
        sceneEl.renderer.shadowMap.enabled = true;
        sceneEl.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      }
    });

    // load models first
    Promise.all([loadSTL(TREE_STL), loadSTL(ORNAMENT_STL)])
      .then(([treeGeo, ornamentGeo]) => {
        // compute tree scale to target height (~1.2m)
        treeGeo.computeBoundingBox();
        const bb = treeGeo.boundingBox;
        const treeHeight = bb.max.y - bb.min.y;
        const targetHeight = 1.2;
        const treeScale = targetHeight / treeHeight;

        // prepare three mesh for tree
        const treeMat = new THREE.MeshStandardMaterial({ color:0x0b8a3e, roughness:0.8, metalness:0.05 });
        const treeMesh = new THREE.Mesh(treeGeo, treeMat);
        treeMesh.scale.setScalar(treeScale);
        treeMesh.castShadow = true;
        treeMesh.receiveShadow = true;

        // center tree base at y=0
        // recompute bbox after scale via clone
        const cloneGeo = treeGeo.clone();
        cloneGeo.applyMatrix4(new THREE.Matrix4().makeScale(treeScale, treeScale, treeScale));
        cloneGeo.computeBoundingBox();
        const center = new THREE.Vector3();
        cloneGeo.boundingBox.getCenter(center);
        // shift mesh so base sits at y=0 and centered on XZ
        treeMesh.position.set(-center.x, -cloneGeo.boundingBox.min.y, -center.z);

        // prepare ornament template mesh
        const ornamentMat = new THREE.MeshStandardMaterial({ color:0xff4444, metalness:0.5, roughness:0.3 });
        const ornamentMeshTemplate = new THREE.Mesh(ornamentGeo, ornamentMat);
        ornamentMeshTemplate.scale.setScalar(ORNAMENT_SCALE);
        ornamentMeshTemplate.castShadow = true;
        ornamentMeshTemplate.receiveShadow = true;

        // compute faces from scaled geometry (so centroid coords match final scaled mesh local)
        const scaledGeo = treeGeo.clone();
        scaledGeo.applyMatrix4(new THREE.Matrix4().makeScale(treeScale, treeScale, treeScale));
        this.treeFaces = computeFacesFromGeometry(scaledGeo);

        // save
        this.treeMesh = treeMesh;
        this.treeGeo = scaledGeo;
        this.ornamentTemplate = ornamentMeshTemplate;

        console.log('Models loaded and prepared');
      })
      .catch(err => {
        console.error('Model load error', err);
        alert('モデル読み込み失敗：tree.stl / ornament.stl を確認してください（コンソール参照）');
      });

    // ar-hit-test events: show reticle and place on select
    sceneEl.addEventListener('ar-hit-test-achieved', (evt) => {
      const r = document.querySelector('#reticle');
      r.object3D.position.copy(evt.detail.position);
      r.object3D.quaternion.copy(evt.detail.rotation);
      r.setAttribute('visible', 'true');
      document.getElementById('placeHint').innerText = 'Tap to place the tree here';
    });
    sceneEl.addEventListener('ar-hit-test-lost', () => {
      document.querySelector('#reticle').setAttribute('visible','false');
      document.getElementById('placeHint').innerText = '';
    });

    sceneEl.addEventListener('ar-hit-test-select', (evt) => {
      if (!this.treeMesh) {
        console.warn('tree not ready');
        return;
      }
      if (this.treePlaced) return;

      // create container entity
      const treeEnt = document.createElement('a-entity');
      treeEnt.setAttribute('id', 'placed-tree');
      // add invisible box collider that approximates tree extents
      // append to scene first so object3D exists
      this.el.appendChild(treeEnt);

      // add THREE mesh to the A-Frame entity's object3D
      // clone treeMesh to avoid shared references
      const meshClone = this.treeMesh.clone();
      // ensure cast/receive shadow on clone
      meshClone.castShadow = true;
      meshClone.receiveShadow = true;
      treeEnt.object3D.add(meshClone);

      // position wrapper at hit pose; mesh is already centered so this works
      treeEnt.object3D.position.copy(evt.detail.position);
      treeEnt.object3D.quaternion.copy(evt.detail.rotation);

      // compute bounding box (world) for collider sizing (approx)
      const box = new THREE.Box3().setFromObject(treeEnt.object3D);
      const size = new THREE.Vector3();
      box.getSize(size);

      // create invisible collider a-box as child (anchored so base at y=0 relative to wrapper)
      const collider = document.createElement('a-box');
      collider.setAttribute('width', size.x.toFixed(3));
      collider.setAttribute('height', size.y.toFixed(3));
      collider.setAttribute('depth', size.z.toFixed(3));
      collider.setAttribute('position', `0 ${ (size.y/2).toFixed(3) } 0`);
      collider.setAttribute('material','opacity:0; transparent:true');
      collider.setAttribute('static-body',''); // static physics body
      treeEnt.appendChild(collider);

      this.treeEntity = treeEnt;
      this.treePlaced = true;
      document.getElementById('placeHint').innerText = 'Tree placed. Press A/X to spawn an ornament.';
      console.log('Tree placed');
    });

    // spawn ornament on controller primary button
    const rightHand = document.querySelector('#rightHand');
    const leftHand = document.querySelector('#leftHand');

    const spawnOrnamentAt = (worldPos, worldQuat) => {
      if (!this.ornamentTemplate) return null;
      if (this.ornaments.length >= MAX_ORNAMENTS) return null;

      // wrapper entity with dynamic-body
      const wrapper = document.createElement('a-entity');
      wrapper.classList.add('ornament');
      wrapper.classList.add('grabbable');
      wrapper.setAttribute('dynamic-body', 'mass:0.35; restitution:0.25');
      wrapper.setAttribute('grabbable','');
      wrapper.setAttribute('grab-listener',''); // for collision handling
      // set initial position
      wrapper.setAttribute('position', `${worldPos.x.toFixed(3)} ${worldPos.y.toFixed(3)} ${worldPos.z.toFixed(3)}`);

      this.el.appendChild(wrapper);

      // add THREE mesh clone into wrapper.object3D (so physics visual and three transform match)
      const meshClone = this.ornamentTemplate.clone();
      meshClone.castShadow = true;
      meshClone.receiveShadow = true;
      wrapper.object3D.add(meshClone);
      if (worldQuat) meshClone.quaternion.copy(worldQuat);

      this.ornaments.push(wrapper);
      return wrapper;
    };

    rightHand.addEventListener('abuttondown', () => {
      const cam = sceneEl.camera.el.object3D;
      const dir = new THREE.Vector3();
      cam.getWorldDirection(dir);
      const camPos = new THREE.Vector3();
      cam.getWorldPosition(camPos);
      const spawnPos = camPos.clone().add(dir.multiplyScalar(SPAWN_DISTANCE));
      spawnOrnamentAt(spawnPos);
    });
    leftHand.addEventListener('abuttondown', () => {
      const cam = sceneEl.camera.el.object3D;
      const dir = new THREE.Vector3();
      cam.getWorldDirection(dir);
      const camPos = new THREE.Vector3();
      cam.getWorldPosition(camPos);
      const spawnPos = camPos.clone().add(dir.multiplyScalar(SPAWN_DISTANCE));
      spawnOrnamentAt(spawnPos);
    });

    // desktop test support
    window.addEventListener('keydown', (e) => {
      if (e.key === 'o') {
        const cam = sceneEl.camera.el.object3D;
        const dir = new THREE.Vector3();
        cam.getWorldDirection(dir);
        const camPos = new THREE.Vector3();
        cam.getWorldPosition(camPos);
        const spawnPos = camPos.clone().add(dir.multiplyScalar(SPAWN_DISTANCE));
        spawnOrnamentAt(spawnPos);
      }
    });

    // register grab-listener once: listens for collide events from physics
    AFRAME.registerComponent('grab-listener', {
      init: function() {
        this.el.addEventListener('collide', (e) => {
          // e.detail.body.el is the collided a-entity (if present)
          const otherEl = e.detail.body && e.detail.body.el;
          if (!otherEl) return;
          // climb parents to identify placed-tree
          let cur = otherEl;
          while (cur) {
            if (cur.id === 'placed-tree') {
              // On collision with placed tree, do surface snap based on nearest face
              stableSnapToTree(this.el);
              break;
            }
            cur = cur.parentElement;
          }
        });
      }
    });

    // stable snap function: find closest face on tree geometry, align and fix object
    const stableSnapToTree = (ornamentEl) => {
      if (ornamentEl.classList.contains('snapped')) return;
      ornamentEl.classList.add('snapped');

      // get world position of ornament (center)
      const worldPos = new THREE.Vector3();
      ornamentEl.object3D.getWorldPosition(worldPos);

      // compute closest face from treeFaces by transforming centroids to world and measuring distance
      if (!this.treeEntity || !this.treeFaces) {
        // fallback: just freeze where it is
        finalizeFreeze(ornamentEl);
        return;
      }

      // ensure tree world matrix is up-to-date
      const treeObj = this.treeEntity.object3D;
      treeObj.updateMatrixWorld(true);

      let bestFace = null;
      let bestDist = Infinity;
      // for each face, compute centroid world pos
      for (let f of this.treeFaces) {
        const centroidWorld = f.centroid.clone().applyMatrix4(treeObj.matrixWorld);
        const d = centroidWorld.distanceTo(worldPos);
        // also penalize faces pointing downward strongly (avoid underside)
        const normalWorld = f.normal.clone().transformDirection(treeObj.matrixWorld).normalize();
        if (normalWorld.y < -0.6) continue; // skip underside faces
        if (d < bestDist) {
          bestDist = d;
          bestFace = { centroidWorld, normalWorld };
        }
      }

      if (!bestFace) {
        // fallback
        finalizeFreeze(ornamentEl);
        return;
      }

      // compute final world pos offset out along normal
      const finalWorldPos = bestFace.centroidWorld.clone().add(bestFace.normalWorld.clone().multiplyScalar(ORNAMENT_OFFSET));
      // compute quaternion aligning +Z to face normal
      const zAxis = new THREE.Vector3(0,0,1);
      const q = new THREE.Quaternion().setFromUnitVectors(zAxis, bestFace.normalWorld.clone().normalize());

      // apply transform: because ornament mesh lives under the a-entity wrapper.object3D,
      // set wrapper's world matrix via position/quaternion set on object3D
      ornamentEl.object3D.position.copy(finalWorldPos);
      ornamentEl.object3D.quaternion.copy(q);
      ornamentEl.object3D.updateMatrixWorld(true);

      // finalize: remove dynamic-body and add static-body so it becomes fixed on tree
      if (ornamentEl.hasAttribute('dynamic-body')) ornamentEl.removeAttribute('dynamic-body');
      ornamentEl.setAttribute('static-body',''); // fixed physics body

      // animation + twinkle
      ornamentEl.setAttribute('animation__scale', {
        property: 'scale',
        to: '1.15 1.15 1.15',
        dur: 220,
        dir: 'alternate',
        loop: 2,
        easing: 'easeOutQuad'
      });

      addTwinkle(ornamentEl);
      console.log('snapped ornament to tree (stable)');
    };

    // finalizeFreeze: simple fallback freeze-in-place
    const finalizeFreeze = (ornamentEl) => {
      ornamentEl.object3D.updateMatrixWorld(true);
      if (ornamentEl.hasAttribute('dynamic-body')) ornamentEl.removeAttribute('dynamic-body');
      ornamentEl.setAttribute('static-body','');
      addTwinkle(ornamentEl);
    };

    // twinkle effect: ring + emissive pulse
    const addTwinkle = (parentEl) => {
      // ring entity
      const tw = document.createElement('a-entity');
      tw.setAttribute('geometry','primitive: ring; radiusInner: 0.03; radiusOuter: 0.06');
      tw.setAttribute('material','color: #ffd700; shader: flat; opacity: 0.95; transparent: true');
      tw.setAttribute('rotation','-90 0 0');
      // place tw at local origin of ornament wrapper (it will inherit wrapper transform)
      tw.setAttribute('position','0 0 0');
      parentEl.appendChild(tw);
      tw.setAttribute('animation__scale', { property: 'scale', to: '1.8 1.8 1.8', dur: 480, easing: 'easeOutQuad' });
      tw.setAttribute('animation__fade', { property: 'material.opacity', to: 0.0, dur: 480, easing: 'linear' });
      setTimeout(()=> tw.remove(), 520);

      // emissive pulse on underlying three.js mesh if available
      const threeObj = parentEl.object3D.children.find(c => c.isMesh);
      if (threeObj && threeObj.material) {
        const start = performance.now();
        const dur = 480;
        function pulse(now) {
          const t = (now - start) / dur;
          if (t > 1) {
            if (threeObj.material.emissive) threeObj.material.emissive.setHex(0x000000);
            return;
          }
          const intensity = Math.sin(t * Math.PI) * 0.7;
          if (threeObj.material.emissive) threeObj.material.emissive.setRGB(intensity, intensity*0.8, intensity*0.2);
          requestAnimationFrame(pulse);
        }
        requestAnimationFrame(pulse);
      }
    };

    // expose for debug
    window._mrDecoratorStable = this;
  }
});

// attach component to scene root
document.querySelector('a-scene').setAttribute('mr-decorator-stable','');
</script>
</body>
</html>
